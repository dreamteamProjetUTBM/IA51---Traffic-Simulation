/** 
 * 
 */
package environments

import java.util.ArrayList
import org.arakhne.afc.gis.road.StandardRoadNetwork
import org.arakhne.afc.gis.maplayer.MapElementLayer
import java.io.File
import org.arakhne.afc.gis.mapelement.MapElement
import org.arakhne.afc.io.dbase.DBaseFileFilter
import org.arakhne.afc.vmutil.FileSystem
import java.net.URL
import java.io.FileInputStream

import org.arakhne.afc.gis.io.shape.GISShapeFileReader
import org.arakhne.afc.math.geometry.d2.d.Rectangle2d
import org.arakhne.afc.gis.road.layer.RoadNetworkLayer
import org.arakhne.afc.gis.road.primitive.RoadNetworkException
import org.arakhne.afc.gis.maplayer.TreeMapElementLayer
import org.arakhne.afc.io.shape.ShapeElementType
import org.arakhne.afc.gis.road.RoadPolyline
import org.arakhne.afc.math.geometry.d2.d.Rectangle2d;
import org.arakhne.afc.io.shape.ESRIBounds
import org.arakhne.afc.gis.location.GeoLocationPointList

import java.io.IOException
import java.io.IOError
import logic.Map

import framework.math.Point2f

/** 
 * @author jerem
 * 
 */
class RoadNetwork {
	
	//val roadNetwork : Environment
	var segments = new ArrayList<RoadSegment>
	var connections = new ArrayList<RoadConnection>
	
	def getSegments : ArrayList<RoadSegment>{
		return segments
	}
	
	def getConnections : ArrayList<RoadConnection>{
		return connections
	}
	
	def LoadShapeFile(name : String) : MapElementLayer<?> {
		var shapefile = new File(name)

		var network : StandardRoadNetwork
		var layer : MapElementLayer<MapElement>
		val dbfFile = FileSystem.replaceExtension(shapefile, DBaseFileFilter.EXTENSION_DBASE_FILE)
		var dbfUrl : URL
		if (dbfFile.canRead()) {
			dbfUrl = dbfFile.toURI().toURL()
		} else {
			dbfUrl = null
		}	
			
		var is : FileInputStream
		try
		{	
			is = new FileInputStream(shapefile)
			assert is != null
			var reader : GISShapeFileReader
			try
			{
				reader = new GISShapeFileReader(is, null, dbfUrl)
				val worldRect = new Rectangle2d();
				val esriBounds = reader.getBoundsFromHeader();
				worldRect.setFromCorners(esriBounds.getMinX(), esriBounds.getMinY(), esriBounds.getMaxX(), esriBounds.getMaxY());
	
				if (reader.getShapeElementType() == ShapeElementType.POLYLINE) {
					reader.setMapElementType(typeof(RoadPolyline));
				}
	
				var element : MapElement
				while ((element = reader.read()) != null) {
					if (element instanceof RoadPolyline) {
						if (network == null) {
							network = new StandardRoadNetwork(worldRect);
						}
						val sgmt = element as RoadPolyline
						try {
							network.addRoadSegment(sgmt);
						} catch (e : RoadNetworkException) {
							throw new RuntimeException(e);
						}
						println(element.geoLocation.toGeodesicPosition.latitude)
						
					
					} else {
						if (layer == null) {
							layer = new TreeMapElementLayer <MapElement> (worldRect);
						}
						try {
							layer.addMapElement(element);
						} catch (e : RoadNetworkException) {
							throw new RuntimeException(e);
						}
					}
				}
			}catch(ex : IOException){
				throw new IOException(ex)
			}
			if (network != null) {
				val networkLayer = new RoadNetworkLayer(network);
				return networkLayer;
			}
			return layer;
		} catch ( exception : IOException) {
			throw new IOError(exception);
		}
	} 
	
	def initMap() {				
		var objs = LoadShapeFile("asset/Ville.shp")
		for(mapEl : objs)
		{
			var tmp = mapEl as RoadPolyline
			if(tmp == null)
				continue
				
			var listCon = new ArrayList<RoadConnection>
			for( pt : tmp.points)
			{
				var geoP = new GeoLocationPointList(pt.x,pt.y).toGeodesicPosition	
				//println(new GeoLocationPointList(pt.x, pt.y).toGeodesicPosition.toString)			
				//var newVec = getXY(geoP.phi, geoP.lambda)
				var newPoint = new Point2f(geoP.phi as float, geoP.lambda as float)
				
				var con = new RoadConnection(newPoint)
				
				if (!connections.exists[el|el.position.x == newPoint.x && el.position.y == newPoint.y])
					connections.add(con)
				
				listCon.add(con)
			}
			//Ne pas oublier de rajouter les points intermédiaires
			var rs = new RoadSegment(listCon.get(0), listCon.get(listCon.length - 1))
			if (!segments.exists[el|(el.start.position == rs.start.position && el.end.position == rs.end.position) || 
				(el.start.position == rs.end.position && el.end.position == rs.start.position)
			])
				segments.add(rs)
		}
		println(segments.length + " segments ont été ajoutés depuis le shapefile")
		println(connections.length + " connections ont été ajoutés depuis le shapefile")	
	}

	/*XY from lat lng */
	 def getXY(lat : double, lng : double) : Point2f
	{
		var screenX = ((lng + 180) * (Map.WIDTH / 360)) as float;
		var screenY = (((lat * (-1)) + 90) * (Map.HEIGHT / 180)) as float;
	
		return new Point2f(screenX, screenY);
	}
	
	def createTestMap() {		
		var milieu = new RoadConnection(new Point2f(Map.WIDTH / 2, Map.HEIGHT / 2))
		var haut = new RoadConnection(new Point2f(Map.WIDTH / 2, Map.HEIGHT / 2 + 100))
		var bas = new RoadConnection(new Point2f(Map.WIDTH / 2, Map.HEIGHT / 2 - 100))
		var gauche = new RoadConnection(new Point2f(Map.WIDTH / 2 - 100, Map.HEIGHT / 2))
		var droite = new RoadConnection(new Point2f(Map.WIDTH / 2 + 100, Map.HEIGHT / 2))
		
		connections.add(milieu)
		connections.add(haut)
		connections.add(bas)
		connections.add(gauche)
		connections.add(droite)
		
		var segH = new RoadSegment(milieu, haut)
		var segB = new RoadSegment(milieu, bas)
		var segG = new RoadSegment(milieu, gauche)
		var segD = new RoadSegment(milieu, droite)
		
		segments.add(segH)
		segments.add(segB)
		segments.add(segG)
		segments.add(segD)
	}

	private

	def loadShapeFile(file : File) : MapElementLayer<?> 
	{
		try 
		{
			var network: StandardRoadNetwork = null;
			var layer: MapElementLayer<MapElement> = null;

			var dbfFile = FileSystem.replaceExtension(file, DBaseFileFilter.EXTENSION_DBASE_FILE);

			var dbfUrl: URL;
			if (dbfFile.canRead()) 
			{
				dbfUrl = dbfFile.toURI().toURL();
			} 
			else 
			{
				dbfUrl = null;
			}

			try
			{
				var is: FileInputStream = new FileInputStream(file);
				
				assert is != null;
				
				try
				{
					var reader: GISShapeFileReader = new GISShapeFileReader(is, null, dbfUrl);
					var worldRect: Rectangle2d = new Rectangle2d();
					var esriBounds : ESRIBounds = reader.getBoundsFromHeader();
					
					worldRect.setFromCorners(
							esriBounds.getMinX(),
							esriBounds.getMinY(),
							esriBounds.getMaxX(),
							esriBounds.getMaxY()
					);

					if (reader.getShapeElementType() == ShapeElementType.POLYLINE) {
						reader.setMapElementType(RoadPolyline);
					}

					var element: MapElement;

					while ((element = reader.read()) != null) 
					{
						if (element instanceof RoadPolyline) 
						{
							if (network == null) 
							{
								network = new StandardRoadNetwork(worldRect);
							}
							
							var sgmt : RoadPolyline = element as RoadPolyline;
							
							try 
							{
								network.addRoadSegment(sgmt);
							} 
							catch (e : RoadNetworkException) 
							{
								throw new RuntimeException(e);
							}
						} 
						else 
						{
							if (layer == null) 
							{
								layer = new TreeMapElementLayer<>(worldRect);
							}
							
							try 
							{
								layer.addMapElement(element);
							} 
							catch (e: RoadNetworkException) 
							{
								throw new RuntimeException(e);
							}
						}
					}
				}
			
				if(network != null) 
				{
					var networkLayer: RoadNetworkLayer = new RoadNetworkLayer(network);
					return networkLayer;
				}
				return layer;
		} 
		catch (exception: IOException) 
		{
			throw new IOError(exception);
		}
	}
	
}
