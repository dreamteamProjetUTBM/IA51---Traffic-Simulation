/** 
 * 
 */
package environments

import java.util.ArrayList
import org.arakhne.afc.gis.road.StandardRoadNetwork
import org.arakhne.afc.gis.maplayer.MapElementLayer
import java.io.File
import org.arakhne.afc.gis.mapelement.MapElement
import org.arakhne.afc.io.dbase.DBaseFileFilter
import org.arakhne.afc.vmutil.FileSystem
import java.net.URL
import java.io.FileInputStream
import org.arakhne.afc.gis.io.shape.GISShapeFileReader
import org.arakhne.afc.math.geometry.d2.d.Rectangle2d
import org.arakhne.afc.gis.road.layer.RoadNetworkLayer
import org.arakhne.afc.gis.road.primitive.RoadNetworkException
import org.arakhne.afc.gis.maplayer.TreeMapElementLayer
import org.arakhne.afc.io.shape.ShapeElementType
import org.arakhne.afc.gis.road.RoadPolyline
import java.io.IOException
import java.io.IOError
import org.arakhne.afc.math.geometry.d2.d.Point2d
import org.newdawn.slick.geom.Vector2f
import logic.Map

/** 
 * @author jerem
 * 
 */
class RoadNetwork {
	
	//val roadNetwork : Environment
	var segments = new ArrayList<RoadSegment>
	var connections = new ArrayList<RoadConnection>
	
	
	def LoadShapeFile() : MapElementLayer<?> {
		var shapefile = new File("asset/Belfort.shp")

		var network : StandardRoadNetwork
		var layer : MapElementLayer<MapElement>
		val dbfFile = FileSystem.replaceExtension(shapefile, DBaseFileFilter.EXTENSION_DBASE_FILE)
		var dbfUrl : URL
		if (dbfFile.canRead()) {
			dbfUrl = dbfFile.toURI().toURL()
		} else {
			dbfUrl = null
		}	
			
		var is : FileInputStream
		try
		{	
			is = new FileInputStream(shapefile)
			assert is != null
			var reader : GISShapeFileReader
			try
			{
				reader = new GISShapeFileReader(is, null, dbfUrl)
				val worldRect = new Rectangle2d();
				val esriBounds = reader.getBoundsFromHeader();
				worldRect.setFromCorners(esriBounds.getMinX(), esriBounds.getMinY(), esriBounds.getMaxX(), esriBounds.getMaxY());
	
				if (reader.getShapeElementType() == ShapeElementType.POLYLINE) {
					reader.setMapElementType(typeof(RoadPolyline));
				}
	
				var element : MapElement
	
				while ((element = reader.read()) != null) {
					if (element instanceof RoadPolyline) {
						if (network == null) {
							network = new StandardRoadNetwork(worldRect);
						}
						val sgmt = element as RoadPolyline
						try {
							network.addRoadSegment(sgmt);
						} catch (e : RoadNetworkException) {
							throw new RuntimeException(e);
						}
						
					
					} else {
						if (layer == null) {
							layer = new TreeMapElementLayer <MapElement> (worldRect);
						}
						try {
							layer.addMapElement(element);
						} catch (e : RoadNetworkException) {
							throw new RuntimeException(e);
						}
					}
				}
			}catch(ex : IOException){
				throw new IOException(ex)
			}
			if (network != null) {
				val networkLayer = new RoadNetworkLayer(network);
				return networkLayer;
			}
			return layer;
		} catch ( exception : IOException) {
			throw new IOError(exception);
		}
	} 
	
	
	def createTestMap() : ArrayList<EnvironmentObject> {
		
		var liste = new ArrayList<EnvironmentObject>
		
		var milieu = new RoadConnection(new Vector2f(Map.WIDTH / 2, Map.HEIGHT / 2))
		var haut = new RoadConnection(new Vector2f(Map.WIDTH / 2, Map.HEIGHT / 2 + 100))
		var bas = new RoadConnection(new Vector2f(Map.WIDTH / 2, Map.HEIGHT / 2 - 100))
		var gauche = new RoadConnection(new Vector2f(Map.WIDTH / 2 - 100, Map.HEIGHT / 2))
		var droite = new RoadConnection(new Vector2f(Map.WIDTH / 2 + 100, Map.HEIGHT / 2))
		
		connections.add(milieu)
		connections.add(haut)
		connections.add(bas)
		connections.add(gauche)
		connections.add(droite)
		
		var segH = new RoadSegment(milieu, haut)
		var segB = new RoadSegment(milieu, bas)
		var segG = new RoadSegment(milieu, gauche)
		var segD = new RoadSegment(milieu, droite)
		
		segments.add(segH)
		segments.add(segB)
		segments.add(segG)
		segments.add(segD)
		
		liste.add(segH)
		liste.add(segB)
		liste.add(segG)
		liste.add(segD)
		
		
		return liste
	}
	
}
